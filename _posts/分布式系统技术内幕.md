
所谓分布式系统，就是利用多个独立的计算机来解决单个节点（计算机）无法处理的存储、计算问题，这是非常典型的分而治之的思想。

# 分布式存储

## 分片方式

1. hash方式

2. 一致性hash（consistent hash）

3. 按照数据范围（range based）

HDFS、MongoDB、PostgreSQL

## 数据分片

slot分槽

## 数据冗余

为了提高分布式系统可用性，一般采用副本策略，如：HDFS的副本块Block，ES的副本分片Shard，redis主从复制



## 分布式持久化

ZK: snapshot + transaction

HDFS: fsimage + edits log

redis: AOF、RDB

## 分布式一致性

ZK: zab算法 zxid(epoch)

QJM: zxid(epoch)



## Quorum机制

Quorum机制无法保证强一致性，因为仅仅通过Quorum机制无法确定最新已经成功提交的版本号。


HDFS高可用QJM：每次写入JournalNode的机器数目达到大多数(W)时，就认为本次写操作成功。




### 一致性

所谓强一致性就是：任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。


最终一致性是弱一致性的强化版，系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。
在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。


在最终一致性的实现过程中，最基本的操作就是保证事务参与者的幂等性，
所谓的幂等性，就是业务方能够使用相关的手段，保证单个事务多次提交依然能够保证达到同样的目的。

## CAP

 CAP 理论中， C：Consistency、A：Availability、P：Partition tolerance 三者不可同时满足



## 分布式事务

```bash
https://mp.weixin.qq.com/s/43wwC4lp77m4foVPEgTRlA
```


2pc的第二阶段，需要等到所有参与者的”YES”回复才会提交事务，只要有一个参与者反馈为”NO”或超时无反馈，都需要中断和回滚事务.

ZK: Leader等待超过半数Follower返回Ack后，再次向所有的Follower分发Commit消息，所有Follower将这一个proposal提交持久化，同时Leader自身也会完成对事务的提交.

### 2PC

两阶段提交 two phase commit

2PC 把事务的执行分为两个阶段，第一个阶段即 prepare 阶段，这个阶段实际上就是投票阶段，协调者向参与者确认是否可以共同提交，
在得到全部参与者的所有回答后，协调者向所有的参与者发布共同提交或者共同回滚的指令，用以保证事务达到一致性。

但是分布式系统中的所有通信均存在着三种状态：成功，失败，超时。
其中，超时状态的存在是我们在设计分布式系统时所面对的永远的痛，2PC 同样存在问题，
尤其是在发送完可以提交的指令后，参与者在没有收到提交或者回滚的指令时，面对已经上锁的资源，面对已经写出去的 undo 或者 redo 日志，参与者会一时陷入手足无措的状态。

### 3PC

3PC 在 commit 之前增加了 preCommit 的过程，使得在参与者在收不到确认时，依然可以从容 commit 或者 rollback，避免资源锁定太久导致浪费。
但是 3PC 同样存在着很多问题。实现起来非常复杂，因为很难通过多次询问来解决系统间分歧问题，尤其是存在超时状态互不信任的分布式网络中，这也就是著名的拜占庭将军问题。

总结一下，2PC 是几乎所有分布式事务算法的基础，后续的分布式事务算法几乎都由此改进而来。


### 传统事务消息实现

传统事务消息实现，一种思路是依赖于 AMQP 协议用来确保消息发送成功，AMQP 模式下需要在发送在发送事务消息时进行两阶段提交，
首先进行 tx_select 开启事务，然后再进行消息发送，最后进行消息的 commit 或者是 rollback。
这个过程可以保证在消息发送成功的同时本地事务也一定成功执行，但事务粒度不好控制，而且会导致性能急剧下降，同时依然无法解决本地事务执行与消息发送的原子性问题。

还有另外一种思路，就是通过保证多条消息的同时可见性来保证事务一致性。但是此类消息事务实现机制更多的是用到 consume-transform-produce 场景中，其本质还是用来保证消息自身事务，并没有把外部事务包含进来。