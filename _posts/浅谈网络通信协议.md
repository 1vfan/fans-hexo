# TCP/IP

TCP/IP分层协议指的是一系列协议的组合，TCP/IP模型参考OSI七层模型可分为四层：链路层、网络层、传输层、应用层，每一层对应的协议有:

1. 链路层协议: Ethernet 802.3、Token Ring 802.5、X.25、Frame relay、HDLC、PPP ATM.
2. 网络层协议: IP、ICMP（控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议）.
3. 传输层协议: TCP（传输控制协议）、UDP（用户数据报协议）.
4. 应用层协议: HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、TELNET（用户远程登录服务协议）、DNS（域名解析服务）、NFS（网络文件系统）、WebSocket.

所以IP是网络层协议，TCP、UDP是传输层协议，HTTP、WebSocket是应用层协议；
而Socket（网络套接字）才是真正能操作的东西，对TCP/IP协议栈的抽象封装的API，提供操作TCP/IP协议的入口，来建立Socket连接.

# TCP、UDP

TCP和UDP协议使用IP协议将数据包从一个网络传送到另一个网络（把IP想像成一条高速公路，它允许TCP、UDP协议的汽车在上面行驶并找到其它电脑的出口，汽车上携带的货物就是像HTTP、FTP这类协议）. 

TCP（Transmission Control Protocol）是一种基于连接的传输控制协议（在正式收发数据前，必须和对方三次握手建立可靠的连接），TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或服务器都没有主动断开前，连接一直存在，故称为长连接；因为会建立连接，所以传输数据无大小限制、稳定可靠、先发先至，但由于连接耗时所以现对慢一些；在并发量大的时候，长连接可以有效的减少连接次数，从而降低连接所带来的性能损耗.

UDP（User Data Protocol）一种无连接的用户数据报协议（传输数据之前不需要交换信息，没有握手建立连接的过程，直接将对应的数据发送到指定的地址和端口），也正因为无需建立连接，所以通信速度快，不稳定，适用于一次只传送少量数据、对可靠性要求不高的应用环境；如通常使用ping命令测试两台主机之间TCP/IP通信是否正常使用的就是UDP协议.

|TCP与UDP协议的差异|TCP|UDP|
|---|---|---|
|收发数据前是否建立连接|建立可靠连接|不建立连接|
|应用场景|传输大量数据|传输少量数据（一般数据包限定64KB以内）|
|数据传输可靠性|可靠|不可靠|
|传输速度|相对慢|快|
|收发特点|先发先至|先发未必先至|

## 三次握手

三次握手的过程:

1. 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）；

2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；ACK:确认字符(Acknowledgement)；

3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手.

我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，确保连接的可靠性，经过三次“对话”之后，主机A才向主机B正式发送数据.

# HTTP

HTTP是使用TCP协议在Web服务器和客户端之间基于请求/响应模式传输数据的协议.

客户端使用Web浏览器向服务器发起HTTP请求，建立TCP连接并发送请求包，服务器接收请求后发送响应信息给客户端，一次请求/响应结束断开连接，在HTTP1.0中为短连接；而HTTP1.1中的keep-alive则是为了优化每次HTTP请求中TCP连接三次握手的耗时和资源开销，只建立一次TCP连接便可在该TCP连接通道上有序阻塞的完成多次请求/响应操作，故为长连接；HTTP2.0中更是采用完全多路复用，并行同时处理多个请求/响应操作.

HTTP2.0是HTTP协议自1999年HTTP1.1发布后的首个更新；与HTTP1.1相比，主要更新包括:

1. HTTP2.0采用二进制格式而非文本格式: 解析更高效；
2. HTTP2.0是完全多路复用的而非有序阻塞的: 只需一个连接即可实现并行，可同时处理多个消息的请求与响应；
3. HTTP2.0使用报头压缩，降低了开销；
4. HTTP2.0让服务器可以将响应主动"推送”到客户端缓存中.


## HTTP请求

http请求由三部分组成，分别是：请求行、消息报头、请求正文

请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。

## HTTP响应

   在接收和解释请求消息后，服务器返回一个HTTP响应消息。

HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文
1、状态行格式如下：
HTTP-Version Status-Code Reason-Phrase CRLF
其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。
状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
常见状态代码、状态描述、说明：
200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
eg：HTTP/1.1 200 OK （CRLF）


# WebSocket

WebSocket也是一种基于TCP协议的应用层协议. 

WebSocket通过HTTP先发送一个标记了``Upgrade``的请求，服务端解析后建立TCP连接，省去了HTTP长连接每次请求都要上传header的冗余，WebSocket可看作是HTTP的优化，不仅仅支持Web应用程序.          

虽然HTTP和WebSocket都基于TCP协议，但二者属于完全不同的两种通讯方式: HTTP基于客户端请求、服务器响应的通讯模式；而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯.

# Socket

而Socket（网络套接字）才是真正能操作的东西，对TCP/IP协议栈的抽象封装的API，提供操作TCP/IP协议的入口，来建立Socket连接.

Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。

这是为了实现以上的通信过程而建立成来的通信管道，其真实的代表是客户端和服务器端的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。
socket只是一种连接模式，不是协议，tcp、udp，简单的说（虽然不准确）是两个最基本的协议,很多其它协议都是基于这两个协议如，http就是基于tcp的。
用socket可以创建tcp连接，也可以创建udp连接，这意味着，用socket可以创建任何协议的连接，因为其它协议都是基于此的。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，
它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

建立Socket连接需要至少一对Socket（套接字），而创建Socket连接可以指定不同的传输层协议，即TCP或UDP，
所以当采用TCP建立连接时，该Socket连接就视为一个TCP连接。而采用UDP则是无连接的。






