---
title: 深入理解JVM
date: 2017-04-17 20:37:00
tags:
- 虚拟机
- java
categories: 
- JVM
---

深入理解java虚拟机：内存结构、垃圾收集、调优等

<!--more-->

# JVM　运行时数据区

![png1](/img/20170417_1.png)

## 线程私有（指令）

### 程序计数器

较小的内存空间，指向当前线程正在执行字节码指令的地址（行号指示器）

但是当前线程正在运行为什么还需要去记录正在执行的指令的行号呢？有以下两点原因：

* 在程序代码中会有一些控制流（if else、switch、return），为了实现控制流的程序跳转
* 由于java虚拟机的多线程是由线程间的轮流切换来分配处理器执行时间，在任何一个确定的时刻，一个单核CPU只会执行一个线程中的指令，因此，线程切换后想要恢复到之前正确的执行位置，需要每个线程都具有独立存储、互不影响的程序计数器

### 虚拟机栈 VM Stack

指向当前线程运行方法时所需的数据、指令、返回地址

* 主要存放局部变量，局部变量表中存放着8种基本数据类型、对象引用（可能是指向对象起始位置的引用指针）、returnAddress（指向一条字节码指令的地址）
* 每一个线程都拥有一块栈空间，所以它的生命周期和线程相同， 一个方法对应一个栈帧，每个栈帧中存储着此方法所包含的局部变量，该方法需要在帧中分配多大的局部变量空间在编译时就确定了，方法运行期间不会改变其大小
* 在一个线程中调用一个方法时会启动一个栈帧，每个方法从被调用->执行完成的过程，就是对应的栈帧在虚拟机栈中从入栈->出栈的过程
* 栈的深度：

一个栈帧大致包括以下内容：

* 局部变量表

存放局部变量：8种基本数据类型、对象引用（可能是指向堆中对象起始位置的引用指针）
存储着此方法所包含的局部变量，该方法需要在帧中分配多大的局部变量空间在编译时就确定了，方法运行期间不会改变其大小

* 操作数栈

存放需要去操作计算的一些中间变量
如执行到 int sum = i + j; 时先将i和j入栈，+的时候i和j同时出栈，将计算后的sum值存储在操作数栈中，最后同步到局部变量表中 

* 动态链接

字面变量到实际使用变量的链接，典型如运行时多态

* 方法出口

包括正常和异常的出栈方式


### 本地方法栈 NM Stack

* 发挥作用类似虚拟机栈，但虚拟机栈服务于Java 方法（字节码），本地方法服务于其他语言

## 线程共享（数据）

### 方法区 perm

* java8后改名叫永久区
* 存放静态变量、字符串常量、class文件的信息（包括字段、方法等，class文件要想运行，需要从硬盘load到内存中的方法区）、即时编译器编译后的代码等数据
* 方法区的大小决定了系统可以保存类的数量
* 方法区的内存回收目标->常量池的回收和类型的卸载，但垃圾回收在此区域较少出现且成效一般，还可选择不实现垃圾回收

为什么静态变量存在方法区中？

静态变量是类共享的（类的所有实例中静态变量值是一致的），假设静态变量存在堆中的，改变某类的一个实例中静态变量的值，则需要同步该类的所有实例，这样显然是鸡肋的；而存在方法区中就很方便，哪个实例需要调用的时候指向方法区中取或修改值就好了.

> 关于运行时常量池

* 运行时常量池是方法区的一部分，并非预置入Class文件常量池的内容才能进入方法区，运行期间也可以将常量放入池中，如：String类的方法[<font color="">intern()</font>](http://www.cnblogs.com/wxgblogs/p/5635099.html)

### 堆 Heap

* 分为new新生代和old老年代
* new:eden、survivor1、survivor2
* old:tenured

* survivor:幸存者，被垃圾收集后还幸存的，两个大小一致
* eden:伊甸园，表示新生的，eden中的对象会产生一大堆，但是在经历一次GC后大部分都会被回收
* tenured:终身制，第一次new出来的对象特别大的时候放到老年代，其他的普通对象直接放到eden

* 经过一次GC后，eden中部分对象依然有引用指向它没有被回收，那么这部分仍被引用指向的对象会转存到survivor1的其中一块去
* 程序运行产生新对象，在第二次GC后，eden中没有被回收的连同上一次survivor1中的一起转存到另一个survivor2中，此时survivor1中的内存就被回收了
* 第三次GC，又会将eden中没有被回收的连同上一次survivor2中的一起转存到survivor1中，survivor2内存被回收，两个survivor如此交替反复
* 如果某些对象在经过多少次的GC之后依然有引用指向没有被回收存在在survivor中，这些对象就会被转存到老年代tenured中

# 直接内存

直接内存不属于JVM运行时数据区，也不是JVM规范定义的内存区域，一般直接内存速度会优于Java堆，JDK1.4引入的NIO库允许Java程序使用直接内存（避免了数据在Java堆和Native堆外内存中来回复制以提高性能），读写频繁的场合可能会使用直接内存.

# java对象分配

分配到栈上和线程本地的过程无需优化调整，jvm会自动分配调节

* 线程对象很小且server的jvm开了栈上分配的优化（默认开的），会优先分配到栈上，注意无逃逸（有一方法内部new一对象，但方法外部有引用指向该对象，那么该对象已经逃逸，此类对象不能放在栈上）优点：栈上分配的效率特别高
* 但是栈空间本来就小，如果栈空间满了，接下来找线程本地内存TLAB（thread local allacation buffer 每个线程会有一个TLAB，线程独享以避免多线程冲突加速对象分配），占用eden区1%的内存空间，好处：多线程时不用通过加线程锁竞争eden就能获取空间，提高效率
* 线程本地内存空间放不下，看看是不是达到老年代的级别（可以通过设置参数），对象特别大直接放到老年代
* 最后都不能放，将对象放到堆上的eden区

# 对象访问方式

> 以一个简单例子阐述虚拟机中对象的存储

```bash
Object o = new Object();
Object o -->作为引用类型-->虚拟栈的本地变量表中
new Object() --> 对象实例数据值、对象类型数据的地址信息（或者说是指针）-->堆中
                                -------------------
                                具体对象类型数据--------------------->方法区中
```

## 句柄方式访问

堆中划分一块内存作为句柄池，栈中的引用存储着对象的句柄地址，句柄池中包括对象实例数据地址（指向堆中另一块存储实例数据值的内存）和对象类型数据地址（指向方法区中存储类型数据的内存）

![png2](/img/20170417_2.png)


## 直接指针访问

栈中的引用直接存储实例对象地址，该地址指向堆中的一个结构化内存，内存中存储着对象实例数据值和对象类型数据地址（指向方法区中存储类型数据的内存）

![png3](/img/20170417_3.png)

# GC

> 什么是垃圾？

垃圾就是没有被任何引用指向的对象，这种说法不完全对，有两个对象a、b,a中有个引用指向b,b中有个引用指向a,除此之外没有任何引用指向这两个对象，那么a和b就是一对垃圾，类似的还有一堆环形垃圾

> 垃圾收集器关注的区域

* 程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，生命周期随线程生而生，线程灭而灭；栈中的栈帧随方法的调用执行入栈，随方法的结束执行出栈；每个栈帧分配多少内存在类结构确定时（编译）就已知的，运行时无法改变其大小；因此当方法或者线程结束后，这些区域的内存会自然跟着被回收，所以这三个区域的内存分配和回收具有确定性，并不需要考虑内存回收的问题

* 而java堆、方法区这两个线程共享区域则不同，如：一个接口中不同的实现类、一个方法中的不同分支；这些只有在程序运行时才能确定需要创建哪些对象，内存的分配和回收都是动态的；所以垃圾收集器关注的是堆和方法区这两个区域

## 引用类型

当内存中的对象只能狭义的分成被引用和未被引用时，我们想实现：当内存空间足够使用时，将一部分未被引用但可能还有用的对象仍然保存在内存中，当GC后内存紧张时再抛弃这些对象；因此在1.2后细分了对象的引用

* 强引用：只要强引用存在，永远不会GC掉被引用的对象
* 软引用：一个对象是软引用可到达，该对象会在内存中停留更长的时间，当前内存不足系统将要发生内存溢出异常前，垃圾收集器才会回收这些软引用可到达的对象，利用这个特性可以做缓存
* 弱引用：一个对象是弱引用可到达，在下一次GC时，无论当前内存是否足够，该对象都会在接下来的回收周期被垃圾收集器销毁
* 虚引用：虚引用完全不会对生存周期有任何影响，唯一的作用就是该对象在被垃圾收集器回收时接收到一个系统通知

## 如何确认垃圾

### 引用计数

* 存在循环引用的问题，不靠谱

### 正向可达算法

* 从root根对象开始计算，只要可以到达的对象都不是垃圾，其余全是垃圾

## 垃圾收集算法

> jvm采用的是分代算法

为什么要分代，新生代与老年代为什么要采用不同的算法？

根据新生代与老年代中对象的特质，使用复制算法或标记压缩算法；新生代回收频率高，回收耗时短，老年代回收频率低，耗时长，应尽量减少老年代的GC.

* 新生代中：一次GC后存活对象少，使用copying复制算法，占用内存空间（或者说是浪费）也不大，效率也很高

* 老年代中：由于都是些顽固对象，垃圾少，一般使用Mark-Compact

> 分区算法

被收购后Oracle在1.7之后提出的概念，主要是将整个内存分成N多个可以独立使用的小空间，细粒度的控制一次回收哪些小空间而不是对整个空间进行GC，以提高性能减少GC的停顿时间.

### Mark-Sweep 标记清除

* 最大的问题：内存的不连续，清除后内存变成碎片化

### Copying 复制

* 将内存区域分成两部分s1和s2，如两个survivor，总有一部分永远不用
* 根据正向可达算法，将s1存活的对象拷贝到s2中，在拷贝的过程中将这些对象压缩形成一块连续的结构化内存，解决了内存碎片化的问题，下次GC后又会同样的将s2压缩连续性的拷贝到s1中
* 优点：内存中拷贝效率很高，同时s1拷贝到s2后，s1作为一块连续的内存做集体清空时，效率也非常高
* 缺点：严重的浪费内存，永远只能用一半的内存

### Mark-Compact 标记压缩

* 通过正向可达标记那些不是垃圾的存活对象向内存的一端压缩，回收后存活对象就变成一块连续的结构化内存空间了，解决了碎片化

* 效率比copying略低，但是老年代中垃圾少，使用标记压缩效率相对来说高很多

## 垃圾收集器

选择那种收集器要根据具体环境的需求，是单处理器的、还是峰值的时候第一优先级停顿时间长点可接受的、还是响应时间比较快的

* serial 单线程串行收集器（不能利用多处理器的硬件），效率是比较高但是处理的数据不大（大概100M） -XX:+UseSerialGC

* parallel 并行收集器，处理的吞吐量比较大（一时刻CPU所能同时处理多少个线程或进程），效率肯定比单线程的高很多，但是JVM停顿时间长 -XX:+UseParallelGC

* CMS 并发收集器（Concurrent Mark Sweep并发标记清除），可以分成好多块区域共同工作，停顿时间短，在CMS回收时系统应用不停止工作

```
-XX:+UseConcMarkSweepGC
-XX:ConcGCThreads  设置并发线程数量
-XX:CMSInitiatingOccuupancyFraction 指定老年代空间使用率到达某一阀值开始CMS回收

由于CMS使用标记清除算法，存在空间碎片化问题
-XX:+UseCMSCompactAtFullCollection CMS回收完成后进行一次碎片整理
-XX:CMSFullGCsBeforeCompaction 设置多少次CMS回收后对内存进行一次压缩
```

* G1 并发收集器，（一种停顿时间和并发量兼顾的折中的收集器）采用分区算法，不仅停顿时间短，同时并发量大

```
-XX:+UseG1GC
-XX:MaxGCPauseMillis 指定最大停顿时间
-XX:ParallelGCThreads 设置并行回收的线程数量
```

> 关于停顿

垃圾回收器是对识别和回收的垃圾对象进行内存清理，回收器执行回收时系统会提顿（终止所有应用线程，以保证没有新垃圾产生及系统状态一致性，更好的标记垃圾对象）.

# OutOfMemoryError

> 除了程序计数器，虚拟机内存中其他运行时区域都有可能报OutOfMemoryError异常

## 堆溢出

## 栈溢出

## 运行时常量池溢出

## 方法区溢出

tomcat中java.lang.OutOfMemoryError: PermGen space异常处理

修改tomcat的bin目录中的catalina.sh
在第一行添加
JAVA_OPTS=-Xms512m -Xmx1024m -XX:PermSize=512m -XX:MaxNewSize=1024m -XX:MaxPermSize=1024m 

## 本地直接内存溢出


# jvm参数

-标准参数  所有jvm都应该支持

-X 非标准参数   每个jvm实现都不同

-XX 不稳定参数  下一个版本可能会取消 又会有新的参数替代

linux一般在tomcat中catalina.sh中JAVA_OPTS上配置以下参数

## 堆配置

```
-XX:+UseSerialGC 配置串行回收器（还可以配置其他回收器）

-Xms256m 设置java程序启动后初始堆大小256M
-Xmx512m 设置java程序所能获得最大堆大小512M

-Xmn 设置新生代的大小，一般会设置占整个堆空间的1/3~1/4
-XX:NewRatio 除了设置新生代大小，还可以设置old/new的比例
-XX:SurvivorRatio 设置新生代中eden/from或eden/to的比例

-XX:MaxTenuringThreshold 指定新生代对象历经多少次GC后进入老年代
-XX:PretenureSizeThreshold 指定对象超过多大直接进入老年代

-XX:+PrintGC JVM启动后GC时会打印日志
-XX:+PrintGCDetails 打印各个区的详细信息
-XX:+PrintCommandLineFlags 将传给虚拟机的参数输出
```

在实际开发中，可以直接设置大小（初始堆==最大堆），以减少程序运行时垃圾回收次数提高性能.

## 栈配置

-Xss 指定线程的最大栈空间，也决定了函数可调用的最大深度

```java
public class TestXss {
    //栈调用深度
    private static int count;
    //递归调用
    public static void recursion() {
        count++;
        recursion();
    }

    public static void main(String[] args) {
        try {
            recursion();
        }catch(Throwable t) {
            System.out.println("调用最大深度：" + count);
            t.printStackTrace();
        }
    }
}
```

## 方法区

可以配置方法区大小以改变存储类信息的数量，默认-XX:MaxPermSize=64m，若系统运行时产生大量类需设置合适大小以避免永久区内存溢出

```
-XX:PermSize=64M
-XX:MaxPermSize=64M
```
