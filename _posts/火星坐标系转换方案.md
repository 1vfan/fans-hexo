---
title: 火星坐标系转换WGS坐标系实现方案
date: 2017-03-07 14:56:47
tags:
- 坐标系
- Java
- Python
- Oracle
categories: 
- GIS
---
记录火星坐标系数据（经纬度）转换成地图WGS坐标系

<!--more-->

# 坐标系简介

## 火星坐标系(GCJ-02)

国测局坐标系，中国标准，天朝为了保卫国家安全，国内出版的各种地图系统（包括电子形式），必须至少采用GCJ-02对地理位置进行首次加密，对真实坐标系统进行人为的加偏处理，把真实的坐标加密成虚假的坐标，这种偏移是非线性的，偏移方向也不确定，从国行移动设备中定位获取的坐标数据使用这个坐标系，如高德地图

## 地球坐标系(WGS84)

大地坐标系，国际标准，是从专业GPS设备中取出的数据的坐标系，是国际地图提供商使用的坐标系，如谷歌地图

# 转换实现方案

## Oracle函数

将转换的算法封装到Oracle的函数中，使用储存过程调用该函数并更新到Oracle表数据，完成坐标系的转换

### 建表T_NODE

将火星坐标系的数据导入到OLDLON和OLDLAT中，将转换后的WGS坐标系存入NEWLON和NEWLAT中，坐标系数据精确到小数点后8位

```bash
 name                       type
OLDLON                  number(38,8)
OLDLAT                  number(38,8)
NEWLON                  number(38,8)
NEWLAT                  number(38,8)
```

### 建package

```bash
create or replace package pg_transform_lonlat is
  type t_tranform_lonlat is record
(
  NewLon number(38,8),
  NewLat number(38,8)
)
```

### 建type

```bash
create or replace type t_tranform_lonlat as object
(
  NewLon number(38,8),
  NewLat number(38,8) 
)
```

### 建function

```bash
create or replace function f_transform_lonlat(OldLon in number, OldLat in number)
  return pg_transform_lonlat.t_tranform_lonlat
is
  pg_t pg_transform_lonlat.t_tranform_lonlat;
  dlon       number(38,8);
  dlat       number(38,8);
  PI         number(38,8);
  a          number(38,8);
  ee         number(38,20);
  radlat     number(38,8);
  magic      number(38,8);
  sqrtmagic  number(38,8);
  x          number(38,8);
  y          number(38,8);
  ret_x      number(38,8);
  ret_y      number(38,8);
  mglon      number(38,8);
  mglat      number(38,8);
begin
  PI := 3.14159265358979323846;
  a  := 6378245.0;
  ee := 0.00669342162296594323;

  if not(OldLon > 72.004 and OldLon < 137.8347 and OldLat > 0.8293 and OldLat < 55.8271) then
    pg_t.NewLon := OldLon;
    pg_t.NewLat := OldLat;
    return(pg_t);
  else
    radlat := OldLat / 180.0 * PI;
    magic := sin(radlat);
    magic := 1 - ee * magic * magic;
    sqrtmagic := sqrt(magic);
    x := OldLon - 105.0;
    y := OldLat - 35.0;
    ret_y := -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(abs(x));
    ret_y := ret_y + (20.0 * sin(6.0 * x * PI) + 20.0 * sin(2.0 * x * PI)) * 2.0 / 3.0;
    ret_y := ret_y + (20.0 * sin(y * PI) + 40.0 * sin(y / 3.0 * PI)) * 2.0 / 3.0;
    ret_y := ret_y + (160.0 * sin(y / 12.0 * PI) + 320 * sin(y * PI / 30.0)) * 2.0 / 3.0;
    dlat := (ret_y * 180.0) / ((a * (1 -ee)) / (magic * sqrtmagic) * PI);
    mglat := OldLat * 2 - (OldLat + dlat);
    ret_x := 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(abs(x));
    ret_x := ret_x + (20.0 * sin(6.0 * x * PI) + 20.0 * sin(2.0 * x * PI)) * 2.0 / 3.0;
    ret_x := ret_x + (20.0 * sin(x * PI) + 40.0 * sin(x / 3.0 * PI)) * 2.0 / 3.0;
    ret_x := ret_x + (150.0 * sin(x / 12.0 * PI) + 300.0 * sin(x / 30.0 * PI)) * 2.0 / 3.0;
    dlon := (ret_x * 180.0) / (a / sqrtmagic * cos(radLat) * PI);
    mglon := OLdLon * 2 - (OldLon + dlon);
    pg_t.NewLon := mglon;
    pg_t.NewLat := mglat;
  end if;
  return (pg_t);
end;
```

### 建procedure

```bash
create or replace procedure p_transform_lonlat(OUTMSG Out Varchar)
AS
  OLDLON     number(38,8);
  OLDLAT     number(38,8);
  NEW_LON    number(38,8);
  NEW_LAT    number(38,8);
  TMP_LON    number(38,8);
  TMP_LAT    number(38,8);
  SYS_REF_CUR_NODE SYS_REFCURSOR;
  RESULTS pg_transform_lonlat.t_tranform_lonlat;
BEGIN
  OPEN SYS_REF_CUR_NODE FOR select OLDLON,OLDLAT from T_NODE;
  LOOP
    FETCH SYS_REF_CUR_NODE INTO TMP_LON,TMP_LAT;
    EXIT WHEN SYS_REF_CUR_NODE%NOTFOUND;
    BEGIN
      RESULTS := f_transform_lonlat(TMP_LON,TMP_LAT);
      NEW_LON := RESULTS.NewLon;
      NEW_LAT := RESULTS.NewLat;
      update T_NODE set NEWLON = NEW_LON,NEWLAT = NEW_LAT where OLDLON = TMP_LON and OLDLAT = TMP_LAT;
      COMMIT;
    END;
  END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
        OUTMSG := 'error:' || SUBSTR (SQLERRM,1,500);
END p_transform_lonlat;
```

## Python脚本

Python与MySQL数据库连接对坐标系数据进行转换，下面的脚本只是提供一组数据供测试，对数据库数据的批量转换待优化

```bash
# -*- coding: utf-8 -*-
import math

pi = 3.14159265359  # π
a = 6378245.0  # 长半轴
ee = 0.00669342162296594323  # 扁率

def GCJtoWGS(lng, lat):
    if out_of_china(lng, lat):
        return lng, lat
    dlat = transformlat(lng - 105.0, lat - 35.0)
    dlng = transformlng(lng - 105.0, lat - 35.0)
    radlat = lat / 180.0 * pi
    magic = math.sin(radlat)
    magic = 1 - ee * magic * magic
    sqrtmagic = math.sqrt(magic)
    dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * pi)
    dlng = (dlng * 180.0) / (a / sqrtmagic * math.cos(radlat) * pi)
    mglat = lat + dlat
    mglng = lng + dlng
    return [lng * 2 - mglng, lat * 2 - mglat]

def transformlat(lng, lat):
    ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + \
        0.1 * lng * lat + 0.2 * math.sqrt(math.fabs(lng))
    ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 *
            math.sin(2.0 * lng * pi)) * 2.0 / 3.0
    ret += (20.0 * math.sin(lat * pi) + 40.0 *
            math.sin(lat / 3.0 * pi)) * 2.0 / 3.0
    ret += (160.0 * math.sin(lat / 12.0 * pi) + 320 *
            math.sin(lat * pi / 30.0)) * 2.0 / 3.0
    return ret

def transformlng(lng, lat):
    ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + \
        0.1 * lng * lat + 0.1 * math.sqrt(math.fabs(lng))
    ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 *
            math.sin(2.0 * lng * pi)) * 2.0 / 3.0
    ret += (20.0 * math.sin(lng * pi) + 40.0 *
            math.sin(lng / 3.0 * pi)) * 2.0 / 3.0
    ret += (150.0 * math.sin(lng / 12.0 * pi) + 300.0 *
            math.sin(lng / 30.0 * pi)) * 2.0 / 3.0
    return ret

def out_of_china(lng, lat):
    """
    判断是否在国内，不在国内不做偏移
    """
    return not (lng > 72.004 and lng < 137.8347 and lat > 0.8293 and lat < 55.8271)

if __name__ == '__main__':
    """
    lng:测试的火星坐标系的经度
    lat:测试的火星坐标系的纬度
    """
    lng = 120.1448
    lat = 30.28407
    result = GCJtoWGS(lng, lat)
    print result
```

## Java程序

> Java项目中将算法封装成一个工具类，连接数据库后调用该工具类即可完成转换

```bash
public class TransformUtil {
	public static boolean outOfChina(double lat, double lng) {
	    if ((lng < 72.004) || (lng > 137.8347)) {
	      return true;
	    }
	    if ((lat < 0.8293) || (lat > 55.8271)) {
	      return true;
	    }
	    return false;
	  }

	  public static double transformLat(double x, double y) {
	    double ret =
	        -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
	    ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
	    ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;
	    ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;
	    return ret;
	  }

	  public static double transformLon(double x, double y) {
	    double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
	    ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
	    ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;
	    ret +=
	        (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;
	    return ret;
	  }
	  /**
	   * 
	   * @param lat纬度
	   * @param lng经度
	   * @return delta[0] 是纬度差，delta[1]是经度差 
	   */
	  public static double[] delta(double lat,double lng){
	    double[] delta = new double[2];
	    double a = 6378245.0;
	    double ee = 0.00669342162296594323;
	    double dLat = transformLat(lng-105.0, lat-35.0);
	    double dLng = transformLon(lng-105.0, lat-35.0);
	    double radLat = lat / 180.0 * Math.PI;
	    double magic = Math.sin(radLat);
	    magic = 1 - ee*magic*magic;
	    double sqrtMagic = Math.sqrt(magic);
	    delta[0] = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI);
	    delta[1] = (dLng * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);
	    return delta;
	  }
}
```