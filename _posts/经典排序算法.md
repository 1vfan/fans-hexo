# 排序算法

内部排序算法，即数据在内存中完成排序；常见的排序都属于比较排序，时间复杂度O(nlogn) ~ O(n^2)，包括冒泡排序、选择排序、插入排序、归并排序、堆排序、快速排序.

另一种则是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等.

排序前后两个值相等的数相对位置保持不变则认为该算法是稳定的.


## 冒泡排序

Bubble Sort

```java
public static void main(String[] args) {
    int[] array = {2,1,4,3,6,5,8,7,0,9};
    sort(array);
    System.out.println(Arrays.toString(array));
}


###简单冒泡排序###
private static void sort(int[] array) {
    int temp = 0;
    for(int i=0; i<array.length-1; i++) {
        for(int j=0; j<array.length-i-1; j++) {
            if(array[j] > array[j+1]) {
                temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
            }
        }
    }
}

###优化冒泡排序###
private static void sort(int[] array) {
    int temp = 0;
    int lastIndex = 0;
    int arrayLength = array.length-1;
    boolean isSorted = true;
    for(int i=0; i<array.length-1; i++) {
        for(int j=0; j<arrayLength; j++) {
            if(array[j] > array[j+1]) {
                temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
                isSorted = false;
                lastIndex = j;
            }
        }
        arrayLength = lastIndex;
        if(isSorted) {
            break;
        }
    }
}



###定向冒泡排序###
private static void sort(int[] array) { 
    int temp = 0;
    int left = 0;
    int right = array.length-1;
    while(left < right) {
        for(int i=0; i<right; i++) {
            if(array[i] > array[i+1]) {
                temp = array[i];
                array[i] = array[i+1];
                array[i+1] = temp;
            }
        }
        right--;
        for(int j=right; j>left; j--) {
            if(array[j] < array[j-1]) {
                temp = array[j];
                array[j] = array[j-1];
                array[j-1] = temp;
            }
        }
        left++;
    }
}
```




## 归并排序

Merge Sort

```java
public static void main(String[] args) {
    int[] array = {2,1,4,3,6,5,8,7,0,9};
    sort(array);
    System.out.println(Arrays.toString(array));
}

private static void sort(int[] array) {
    int left = 0;
    int right = array.length -1;
    int[] temp = new int[array.length];
    sort(array, left, right, temp);
}

private static void sort(int[] array, int left, int right, int[] temp) {
    if(left < right) {
        int mid = (left + right)/2;
        sort(array, left, mid, temp);
        sort(array, mid+1, right, temp);
        merge(array, left, mid, right, temp);
    }
}

private static void merge(int[] array, int left, int mid, int right, int[] temp) {
    int i = left;
    int j = mid + 1;
    int t = 0;
    while(i <= mid && j <= right) {
        if(array[i] <= array[j]) {
            temp[t++] = array[i++];
        }else {
            temp[t++] = array[j++];
        }
    }
    while(i <= mid) {
        temp[t++] = array[i++];
    }
    while(j <= right) {
        temp[t++] = array[j++];
    }
    t = 0;
    while(left <= right) {
        array[left++] = temp[t++];
    }
}
```




## 快速排序

Qucik Sort

```java
public static void main(String[] args) {
    int[] array = {2,1,4,3,6,5,8,7,9};
    sort(array);
    System.out.println(Arrays.toString(array));
}

private static void sort(int[] array) {
    int left = 0;
    int right = array.length -1;
    sort(array, left, right);
}

private static void sort(int[] array, int left, int right) {
    if(left > right) {
        return;
    }else {
        int key = merge(array, left, right);
        sort(array, left, key-1);
        sort(array, key+1, right);
    }
}

private static int merge(int[] array, int left, int right) {
    int temp = 0;
    int key = array[left];
    while(left < right) {
        while(left < right && key <= array[right]) {
            right--;
        }
        if(left < right) {
            temp = array[left];
            array[left] = array[right];
            array[right] = temp;
            left++;
        }
        while(left < right && key >= array[left]) {
            left++;
        }
        if(left < right) {
            temp = array[left];
            array[left] = array[right];
            array[right] = temp;
            right--;
        }
    }
    return left;
}
```

# 算法应用


Java系统提供的Arrays.sort函数，对于基础类型，底层使用快速排序；对于非基础类型，底层使用归并排序，为何这样设计？

考虑到排序算法的稳定性：对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序. 


