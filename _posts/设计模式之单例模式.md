---
title: 设计模式之单例模式
date: 2017-03-20 16:20:30
tags:
- 设计模式
categories: 
- 设计模式
---

单例模式简述

<!--more-->

## 简述 

一般的单例模式指的是单个JVM中一个类仅有一个实例。

单例的核心：类的构造方法私有化；私有静态引用指向在类内部实例化的对象；外界通过公有静态方法获取实例化对象的引用。

## Spring

Spring中默认情况下（scope="singleton"）的单例则指的是单个Spring容器中ApplicationContext共享，容器中一个bean对象仅有一个实例（bean id）；当然在单个JVM中可以有多个Spring容器。

```java
ApplicationContext context = new FileSystemXmlApplicationContext("applicationContext.xml");
AA aa1 = (AA) context.getBean("aa");
AA aa2 = (AA) context.getBean("aa");
System.out.println(aa1);
System.out.println(aa2);

//com.stefan.AA@989e0c
//com.stefan.AA@989e0c
```

## 一般单例实现

### Hungry Parrten

类加载创建对象；线程安全

```java
public class SingletonHungry {

    private SingletonHungry() {};

    private static SingletonHungry instance = new SingletonHungry();

    public static SingletonHungry getInstance() {
        return instance;
    }
}
```


```java
public class SingletonStaticBlock {

    private SingletonStaticBlock() {};

    private static SingletonStaticBlock instance;

    static {
        instance = new SingletonStaticBlock();
    }

    public static SingletonStaticBlock getInstance() {
        return instance;
    }
}
```

### Lazy Parrten

刚需时创建对象；线程不安全（多线程场景，唯一实例尚未创建，多个线程同时调用创建方法且同时没有检测到唯一实例的存在，会各自创建一个实例）

```java
public class SingletonLazy {

    private SingletonLazy() {};

    private static SingletonLazy instance;

    public static SingletonLazy getInstance() {
        if(instance == null) {
            instance = new SingletonLazy();
        }
        return instance;
    }
}
```

### Double Check

刚需时创建对象；线程安全

```java
public class SingletonDoubleCheck {

    private SingletonDoubleCheck() {};

    private static volatile SingletonDoubleCheck instance; 

    public static SingletonDoubleCheck getInstance() {
        if(instance == null) {
            synchronized(SingletonDoubleCheck.class) {
                if(instance == null) {
                    instance = new SingletonDoubleCheck();
                }
            }
        }
        return instance;
    }
}
```

### Static Inner Class

刚需时创建对象；线程安全

```java
public class SingletonStaticInner {

    private SingletonStaticInner() {};

    private static class SingletonHolder { 
        private static SingletonStaticInner instance = new SingletonStaticInner();
    }

    public static SingletonStaticInner getInstance() {
        return SingletonHolder.instance;
    }
}
```

## Enum to Singleton

以上都是通过私有化构造方法实现单例，但是开启权限后通过反射可以调用私有构造器，所以存在反射攻击隐患；同时在以上方式实现中，序列化前后实例对象会发生改变（任何一个readObject方法，无论显式或默认，它都会返回一个新建的实例，该新建实例不同于其类初始化时创建的实例）。

```java
public class SingletonReflectAttack {

    public static void main(String[] args) throws Exception {

        SingletonHungry singletonHungry1 = SingletonHungry.getInstance();
        System.out.println(singletonHungry1);

        //私有构造器并不完全保险，客户端可以借助setAccessible(true)通过反射调用私有构造器
        Constructor<SingletonHungry> constructor = SingletonHungry.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        SingletonHungry singletonHungry2 = constructor.newInstance();
        System.out.println(singletonHungry2);

        SingletonHungry singletonHungry3 = SingletonHungry.getInstance();
        System.out.println(singletonHungry3);
    }
}


//singleton.SingletonHungry@27385846
//singleton.SingletonHungry@642b6fc7
//singleton.SingletonHungry@27385846
```

``单元素的枚举类型已经成为实现单例的最佳方法``，如下实现了简洁、线程安全、防反射攻击、实例对象序列化前后不变的单例。


```java
public enum SingletonEnum {

    INSTANCE;

    private Singleton singleton;

    private SingletonEnum() {
        singleton = new Singleton();
    };

    public Singleton getInstance() { 
        return singleton;
    } 
}


//Singleton singleton = SingletonEnum.INSTANCE.getInstance();
```