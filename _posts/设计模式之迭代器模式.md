---
title: 设计模式之迭代器模式
date: 2017-04-20 16:20:30
tags:
- 设计模式
categories: 
- 设计模式
---

迭代器模式简述

<!--more-->

迭代器是一种设计模式，通过调用一个统一的接口顺序的访问一组对象集合中的各个元素，但又不暴露其内部底层细节.

## Iterable接口

Iterable接口 (java.lang.Iterable) 是Java集合的顶级接口之一.

一个实现Iterable接口的集合可以进行多次的遍历，当每次执行遍历操作的时候把自己本身传给实现Iterator的对象，这样每次遍历的操作都不会影响这个集合的内部元素.

```java
package java.lang;

public interface Iterable<T> {
    /**
     * @return an Iterator.
     */
    Iterator<T> iterator();
}
```

## Iterator接口

Iterator接口则是Java迭代器最简单的实现，是执行具体的遍历操作.

```java
package java.util;

public interface Iterator<E> {

    boolean hasNext();

    E next();

    //将迭代器新返回的元素删除
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
}
```


## Collection

Collection实现了Iterable接口，所以Collection及其子类(List Set Queue)也都具备迭代功能.

```java
package java.util;

public interface Collection<E> extends Iterable<E> {

}

public interface Set<E> extends Collection<E> {
}

public interface List<E> extends Collection<E> {
}

public interface Queue<E> extends Collection<E> {
}
```


## Map

虽然Map没有实现Iterable接口，但可以通过Map内部定义的Collection集合对象间接实现迭代遍历.

```java
package java.util;

public interface Map<K,V> {
    Collection<V> values();

    Set<K> keySet();

    Set<Map.Entry<K, V>> entrySet();
}
```

迭代方式一: Map可以返回一个包含Key键的Set集合，就可以通过迭代这个Set集合，间接获取Map的Value值.

```java
Iterator<String> item = map.keySet().iterator();
while(item.hasNext()) {
    String key = item.next();
    String value = map.get(key);
}
```

迭代方式二: Map也可以返回一个包含Map.Entry(映射项)对象的Set集合，可以直接获取Value值.

```java
Iterator<Map.Entry<String, String>> item = map.entrySet().iterator();
while(item.hasNext()) {
    Map.Entry<String, String> mapEntry = item.next();
    String key = mapEntry.getKey();
    String value = mapEntry.getValue();
}
```


## Iterable与Iterator

可以看出所有的集合类都是直接或间接继承了Iterable接口的，既然Iterable内部只有一个方法来返回一个Iterator迭代器，到最后还是使用Iterator，为什么集合类选择Iterable而不直接实现Iterator接口呢？

Iterator接口中的核心方法都依赖当前迭代位置，只单纯实现Iterator接口的集合类内部只会有一个迭代器，在迭代过程中会记录当前迭代位置的'指针'并不会重置，那么旧迭代器在多线程或在不同方法中调用时就会影响迭代结果；而实现Iterable接口会在每一次调用时都可以获得一个新的Iterator迭代器，以保证集合类每一次获得的Iterator都是从第一个元素开始遍历的，迭代器之间互不干扰.

注意：可以使用foreach进行遍历的集合都实现了Iterable接口，所以如果自定义类实现了Iterable接口并且实现了该接口中iterator()的具体定义，则可以通过foreach语法来遍历该自定义的类.

## 案列

在Lucene中的document类实现.

```java
public final class Document implements Iterable<IndexableField> {
 
  //以ArrayList来保存不同的Field内容
  private final List<IndexableField> fields = new ArrayList<>();
 
  /** Constructs a new document with no fields. */
  public Document() {}
 
  @Override
  public Iterator<IndexableField> iterator() {
    return fields.iterator();
  }
}
```

