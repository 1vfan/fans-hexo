---
title: Java高质量代码编写之道
date: 2017-04-02 19:43:01
tags:
- java
categories: 
- java
---

学习<阿里巴巴Java开发手册>和<改善Java程序的151个建议>后总结内化

<!--more-->

## 枚举Enum

在JDK1.5之前只有两种常量声明方式：类常量、接口常量，1.5以后新增枚举常量声明方式；枚举类名最好带Enum后缀，所有常量声明方式的成员名称都需要全大写，单词间用下划线隔开

> 类常量：

```java
/**
 * 常量类
 * @author lf
 */
public class CodeConstant {
    public static final Integer LOWER_CODE  = 0;
    public static final Integer NOMAL_CODE  = 1;
    public static final Integer HIGHER_CODE = 2;	
}
```

> 接口常量：

```java
/**
 * 常量接口
 * @author lf
 */
public interface CodeInterface {
    Integer LOWER_CODE  = 0;
    Integer NOMAL_CODE  = 1;
    Integer HIGHER_CODE = 2;	
}
```

> 枚举常量：

枚举其实就是特殊的常量类，且构造方法被默认强制是私有的；变量值仅在一个范围内变化，且带有名称之外的延伸属性；强制所有的枚举类型字段必须要有注释，说明每个数据项的用途

```java
/**
 * 枚举类
 * @author lf
 */
public enum CodeEnum {

    LOWER_CODE(0, "上级"),
    NOMAL_CODE(1, "自身"),
    HIGHER_CODE(2, "下级");
	
    private Integer code;
    private String desc;

    Getter/Setter...
	
    //私有构造
    private CodeEnum(Integer code, String desc) {
        this.code = code;
        this.desc = desc;
    }

    //自定义方法:根据code值生成对应的CodeEnum类型
    public static CodeEnum getInstance(Integer code) {
        return Arrays.asList(values())
                .stream()
                .filter(item -> code != null && item.getCode().equals(code))
                .findFirst()
                .orElse(null);
    }
}

/**
 * 随机测试类
 * @author lf
 */
public class CodeSearch {
    public static void main(String[] args) {
        for(int i=0; i<5; i++) {
            Integer code = new Random().nextInt(4);
            System.out.println("code值：" + code);
            CodeEnum codeEnum= CodeEnum.getInstance(code);
            if(codeEnum == null) {
                System.out.println("超出枚举项范围，orelse(null)将codeEnum设置为空！");
                return;
            }
            switch(codeEnum) {
            case LOWER_CODE:
                System.out.println(codeEnum.getCode() + "," + codeEnum.getDesc());
                break;
            case NOMAL_CODE:
                System.out.println(codeEnum.getCode() + "," + codeEnum.getDesc());
                break;
            case HIGHER_CODE:
                System.out.println(codeEnum.getCode() + "," + codeEnum.getDesc());
                break;
            default:
                System.out.println("输入有误！");
                break;
            }
            System.out.println("----------------------------");
        }
    }
}

打印结果：
code值：2
2,下级
----------------------------
code值：1
1,自身
----------------------------
code值：0
0,上级
----------------------------
code值：2
2,下级
----------------------------
code值：3
超出枚举项范围，orelse(null)将codeEnum设置为空！
```

注意switch判断中易出现的NullPointerException，我们在自定义方法中设置了当输入的code值不在枚举项范围中是则返回null的CodeEnum；但编译时，编译器判断出switch的参数是枚举类型，会根据枚举的排序值与每一个枚举常量的排序值进行匹配（如下伪代码），当CodeEnum=null，则执行ordinal方法时会报空指针异常；所以在switch前需要判断CodeEnum是否为空.

```bash
switch(codeEnum.ordinal()) {
case CodeEnum.LOWER_CODE.ordinal():
....
case CodeEnum.NOMAL_CODE.ordinal():
....
case CodeEnum.HIGHER_CODE.ordinal():
....
}
```

> 枚举类型的优点：

常量类和常量接口都必须对常量赋值，否则编译无法通过；而枚举方式则不必要；同时枚举还可以对枚举项进行描述（如上的desc）便于理解枚举项代表的意义，比其他两种添加注释实现的方式更加友好简洁.

可以使用内置方法（如排序的ordinal方法、比较的compareTo方法、转换的valueOf方法），因为每个枚举类都是java.lang.Enum的子类.

```java
//枚举只需通过内置values()方法即可遍历所有的枚举项，而其他两种则需要使用反射实现
for(CodeEnum ce : CodeEnum.values()) {
    System.out.println(ce.getCode() + "," + ce.getDesc());
}

打印结果：
0,上级
1,自身
2,下级


//通过valueOf()方法可以将字面量相同的String类型名称转换成枚举项，但是不能做简单的方法返回值为null的if、else判断，因为在valueOf源码实现中转换不成功就会抛IllegalArgumentException，则我们定义的else为null程序就白写了.
public static <T extends Enum<T>> T valueOf(Class<T> enumType, String name) {
T result = enumType.enumConstantDirectory().get(name);
if (result != null)
    return result;
if (name == null)
    throw new NullPointerException("Name is null");
throw new IllegalArgumentException(
    "No enum constant " + enumType.getCanonicalName() + "." + name);
}

//正确方式实现
try{
    CodeEnum ce = CodeEnum.valueOf(code);
    //成功之后的操作...
}catch(Exception e){
    //失败后异常操作...
    System.out.println("无相关枚举项");
}
```

同时还可以自定义方法，如下

```java
//自定义方法:根据code值生成对应的CodeEnum类型
public static CodeEnum getInstance(Integer code) {
    return Arrays.asList(values())
            .stream()
            .filter(item -> code != null && item.getCode().equals(code))
            .findFirst()
            .orElse(null);
}
```

但是枚举相较常量类和常量接口，不足的是无法通过继承实现扩展，但是一般常量在构建后也就定义完毕了，很少需要扩展.


## 排序Sort

java中为自定义实现数据排序逻辑提供了两种方式：实现Comparable接口、实现Comparator接口.

注意：Comparator 要满足如下三个条件，否则Arrays.sort(),Collections.sort()可能会报``IllegalArgumentException``异常.

```bash
x.compareTo(y) 与 y.compareTo(x) 比较结果相反；
若x > y，y > z，则 x > z ；
若x = y，则 x.compareTo(z) 与 y.compareTo(z) 比较结果相同.
```

> Comparable

一个类实现了Comparable接口，compareTo()将作为该实现类唯一固定的默认排序算法，基本不会改变.

```java
//公司员工类
import org.apache.commons.lang.builder.CompareToBuilder;
public class Emp implements Comparable<Emp>{

	private Integer id;
	private String name;
	private PositionEnum position;
	
	public Emp(Integer id, String name, PositionEnum position) {
		this.id = id;
		this.name = name;
		this.position = position;
	}
	
    //getter、setter省略
	public String toString () {
		return this.id + " , " + this.position + " , " + this.name;
	}

	//实现类的默认排序
	@Override
	public int compareTo(Emp emp) {
		return new CompareToBuilder()
					.append(this.id, emp.id)
					.toComparison();
	}
}

//员工职位
public enum PositionEnum {
	boss, manager, staff
}
```

上述实现类中compareTo()方法规定了默认排序算法按员工入职编号排序：

```java
List<Emp> list = new ArrayList<Emp>(5);

list.add(new Emp(1, "stefan1", PositionEnum.boss));
list.add(new Emp(4, "stefan4", PositionEnum.staff));
list.add(new Emp(5, "stefan5", PositionEnum.manager));
list.add(new Emp(2, "stefan2", PositionEnum.manager));
list.add(new Emp(3, "stefan3", PositionEnum.staff));

//按入职时间排序
Collections.sort(list);

for(Emp emp : list) {
    System.out.println("sort after: " + emp.toString());
}
```

> Comparator

Comparator则是一个用于排序的工具类接口，实现类扩展的比较器排序逻辑与原实现Comparable接口规定的默认逻辑无关联，一个类可以实现多个Comparator接口，具有多种排序算法.

```java
public class PositionComparator implements Comparator<Emp>{

	//扩展比较器的排序逻辑
	@Override
	public int compare(Emp e1, Emp e2) {
		return e1.getPosition().compareTo(e2.getPosition());
	}
}
```

使用Collections.sort(List<T> list)的重载方法调用扩展的比较器，实现按员工职位从高到地排序：

```java
//按职位高低排序
Collections.sort(list, new PositionComparator());

for(Emp emp : list) {
    System.out.println("sort after: " + emp.toString());
}
```

> 组合条件

通常我们需要先按职位高低排序后同职位再按入职时间排序，对于这种组合条件的排序，这里使用Apache的工具类实现

```java
Collections.sort(list, new Comparator<Emp>() {
    @Override
    public int compare(Emp e1, Emp e2) {
        return new CompareToBuilder()
                .append(e1.getPosition(), e2.getPosition())
                .append(e1.getId(), e2.getId())
                .toComparison();
    }
});

for(Emp e : list) {
    System.out.println("sort id and position after: " + e.toString());
}
```

## 遍历Traverse

> 下标方式遍历

```java
##读取性能较高
for(int i=0; i<array.length; i++) {
    System.out.println(array[i]);
}
```

> 迭代方式遍历

java中的foreach用法是iterator迭代器的变形用法，由于类型转换会比迭代器慢一点，但是时间复杂度都是一样的.

```java
##迭代遍历集合
Collection<T> coll;

##1.完整迭代方式
Iterator<T> itr = coll.iterator();
while(itr.hasNext()) {
    T item = itr.next();
    System.out.println(item);    
}

  ||
 \  /
  \/
##1.迭代精简方式
for(Iterator<T> i = coll.iterator(); i.hasNext(); ) {
    System.out.println(i.next());
}

  ||
 \  /
  \/
##3.foreach迭代方式（遍历过程中不能操作(删除、替换)数据集合）
for(T item : coll) {
    System.out.println(item);
}
```

> 不同列表选择不同遍历方式

列表遍历并不局限于某一种，以 ``随机存取列表`` 和 ``有序存取列表`` 为例.

```java
##随机存取：ArrayList实现了RandomAccess接口，宜用下标方式遍历
##有序存取：LinkedList实现了双向链表，宜用迭代器遍历

List<String> list;

if(list instanceof RandomAccess) {
    for(int i =0; i< list.size(); i++){
        String str = list.get(i);
        System.out.println(str);
    }
} else {
    for(String str : list) {
        System.out.println(str);
    }
}
```
